
import openai
import json
import pandas as pd
import numpy as np
from enum import Enum
import time
from datetime import datetime

TOKEN_VALUE="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"

class ComparationType(Enum):
    DESCRIPTION = 'DESCRIPTION'
    VERSIONS = 'VERSIONS'

def open_cve_list(source):
    cve_information = pd.read_csv(source, index_col=False)
    return cve_information

def call_open_api(token, cve_prompt):
    fail = False
    generated_text = ""
    try:
        openai.api_key = token
        prompt = cve_prompt
        response = openai.Completion.create(
        engine="text-davinci-003",
        prompt=prompt, 
        max_tokens=3000
        )
        generated_text = response.choices[0].text.strip()
    except Exception as e:
        retry_time = 2
        print(f"Error {e}. Retrying in {retry_time} seconds..." , flush=True)
        time.sleep(retry_time)
        return call_open_api(token, cve_prompt)

    return generated_text, fail

def load_prompt_text(file, cve_id, cve_description,module,version):
    with open(file) as f:
        lines = " ".join([l.rstrip("\n") for l in f]) 
        lines = lines.replace("<module>", module)
        lines = lines.replace("<version>", version)
        lines = lines.replace("<cve-id>", cve_id)
        lines = lines.replace("<cve-description>", str(cve_description))
        return lines

def clean_result(string, cve_id):
    success = True
    json_string = ""
    try:
        json_string = json.loads(string)
    except:
        print("An exception occurred parsing cve", flush=True)
        success = False
        json_string = {"CVE_ID": cve_id, "vulnerable_versions": []}
    
    return json_string, success

def save_result(json_string,cve_id): 
    with open(cve_id+'.json', 'w') as f:
        json.dump(json_string, f, indent=None)


def analyze_cve(token, cve_prompt, cve_id,attemp=0):
    print("Running CVE ",cve_id, flush=True)
    response, fail = call_open_api(token, cve_prompt)
    success, vulnerableEvaluation = processResponse(response)
    isVulnerable = vulnerableEvaluation
    # print("Success ",success)
    if not success:
        if attemp < 2:
            print("Retrying cve " + cve_id, flush=True)
            analyze_cve(token, cve_prompt, cve_id, attemp + 1)
        else:
            print("Abort cve " + cve_id, flush=True)
            isVulnerable = None
    return isVulnerable      

def analyzeDescription(cve_id,description,module,version):
    prompt_file = 'isVulnerable.txt'
    token = TOKEN_VALUE
    cve_st = time.time()
    cve_prompt = load_prompt_text(prompt_file,cve_id,description,module,version)
    print("Analyzing Description ",cve_id, flush=True)  
    response = analyze_cve(token, cve_prompt, cve_id)
    print("openai response ",response, flush=True)
    cve_et = time.time()
    elapsed_time = cve_et - cve_st
    # print("response ",response)
    # print("elapsed_time ",elapsed_time)
    return response

def analyzeVersions(cve_id,vulnerable_array,module,version):
    prompt_file = 'isVulnerableVersions.txt'
    token = TOKEN_VALUE
    cve_st = time.time()
    cve_prompt = load_prompt_text(prompt_file,cve_id,vulnerable_array,module,version)
    print("Analyzing Versions ",cve_id, flush=True) 
    response = analyze_cve(token, cve_prompt, cve_id)
    cve_et = time.time()
    elapsed_time = cve_et - cve_st
    print("openai response ",response, flush=True)
    # print("elapsed_time ",elapsed_time)
    return response

def processResponse(response):
    all_words = response.replace(".","")
    correct = False
    vulnerable = None
    if "true" in all_words.lower():
        vulnerable = True
        correct = True
    elif "false" in all_words.lower():
        vulnerable = False
        correct = True
    return correct, vulnerable
    

def searchCVEData(cve_id, cve_list):
    for i, cve in cve_list.iterrows():
        if cve["CVE-ID"] == cve_id:
            return cve

def check_database(cve_id, module, version, type=ComparationType.DESCRIPTION, vulnerable_array=None):
    source_file = 'bacnet_cve.csv'
    cves_info = open_cve_list(source_file)
    cve = searchCVEData(cve_id, cves_info)
    response = False
    if type == ComparationType.DESCRIPTION:
        response = analyzeDescription(cve["CVE-ID"], cve["DESCRIPTION"], module, version)
    elif type == ComparationType.VERSIONS:
        response = analyzeVersions(cve["CVE-ID"], vulnerable_array, module, version)
    return response
    


# print(check_database("CVE-2019-13939","desigo PXC36.1-E.D","V6.00.204"))
# print(check_database("CVE-2019-13939","desigo PXC36.1-E.D","V6.00.204", ComparationType.VERSIONS,
# #                      {"vulnerable_versions":  [
# #                 {
# #                     "module": "APOGEE MEC/MBC/PXC (P2)",
# #                     "versions": "< V2.8.2"
# #                 },
# #                 {
# #                     "module": "APOGEE PXC Series (BACnet)",
# #                     "versions": "< V3.5.3"
# #                 },
# #                 {
# #                     "module": "APOGEE PXC Series (P2)",
# #                     "versions": ">= V2.8.2 and < V2.8.19"
# #                 },
# #                 {
# #                     "module": "Desigo PXC00-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC00-U",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC001-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC100-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC12-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC128-U",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC200-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC22-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC22.1-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC36.1-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC50-E.D",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXC64-U",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Desigo PXM20-E",
# #                     "versions": ">= V2.3x and < V6.00.327"
# #                 },
# #                 {
# #                     "module": "Nucleus NET",
# #                     "versions": "All versions"
# #                 },
# #                 {
# #                     "module": "Nucleus RTOS",
# #                     "versions": "All versions"
# #                 },
# #                 {
# #                     "module": "Nucleus ReadyStart for ARM, MIPS, and PPC",
# #                     "versions": "< V2017.02.2 with patch \"Nucleus 2017.02.02 Nucleus NET Patch\""
# #                 },
# #                 {
# #                     "module": "Nucleus SafetyCert",
# #                     "versions": "All versions"
# #                 },
# #                 {
# #                     "module": "Nucleus Source Code",
# #                     "versions": "All versions"
# #                 },
# #                 {
# #                     "module": "SIMOTICS CONNECT 400",
# #                     "versions": "< V0.3.0.330"
# #                 },
# #                 {
# #                     "module": "TALON TC Series (BACnet)",
# #                     "versions": "< V3.5.3"
# #                 },
# #                 {
# #                     "module": "VSTAR",
# #                     "versions": "All versions"
# #                 }
# #             ]}))

# print(check_database("CVE-2018-7276","Lutron Quantum BACnet","3.2.243", ComparationType.VERSIONS,{"vulnerable_versions": [
# #                 {
# #                     "module": "Lutron Quantum BACnet Integration 2.0",
# #                     "versions": "3.2.243"
# #                 }]}))